---
date: 2021/12/21 18:09
title: Linux脚本
tag: [shell,linux,脚本]
---



::: tip

Linux中的脚本，都是以`.sh`命名，但是并不是必须以`.sh`为后缀名，我们也可以以`var`为文件名，在此文件里面，写一些变量，然后`./var`这样也可以运行，但是为了规范，都是以`.sh`为后缀名

在运行脚本文件的时候，一定要保证，此脚本文件拥有可执行的权利，为了方便，我们可以直接将`aaa`文件夹下的所有脚本赋予可执行的权利

```sh
chmod -R u+x aaa #不能是-r
```

:::



## 变量

1. 变量推荐都是大写，`A=100`,没有分号结束符

2. 定义变量，等号两侧不能有空格

   ```sh
   #错误
   C = 100
   
   # 正确
   C=100
   ```

3. 使用`echo`的时候，可以使用字符串拼接，字符串为`""`，`$变量名`可以在字符串中，引用此变量值

   ```sh
   #错误
   C=100
   echo 'C的值为: $C'
   
   #正确
   echo "C的值为: $C"
   ```

4. `unset 变量名`是撤销变量的赋值，`unset C`，输出`C`时为空

5. 静态变量定义`readonly B=2`，不能对B进行unset

6. ``这个符号是将某个指令的运行结果，赋值给变量

   ```sh
   C=`date`
   # 也可以使用=$(date)
   D=$(date)
   ```

   那么输出C就是运行`date`的结果



```sh
#!/bin/bash
A=100
echo $A
echo "A = $A"

unset A

echo $A

C=`date`
echo '本地时间为: $C'

echo "我的环境变量为: $PATH"
```





## 环境变量

::: tip

在`/etc/profile`文件里面使用`export`导出的变量，都是全局变量，我们可以直接使用，比如`PATH`

```sh
export AURORA=https://aurora.xcye.xyz
```

那么我们在任何地方使用`echo $AURORA`都可以得到`AURORA`这个变量的值



> 请注意以下
>
> 1. 一定要使用`export`
> 2. 变量大写
> 3. 保存之后，一定要运行`source /etc/profile`使之生效
> 4. 使用`/etc/profile`中的变量时，一定要加上`$`

:::



## 位置参数变量

如果我们输入`./po.sh 11 22 33 44 55`，那么我们可以通过位置参数变量，获取到这些参数

> `$n` （功能描述：n 为数字，$0 代表命令本身，$1-$9 代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如${10}） 
>
> `$*` （功能描述：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体） 
>
> `$@`（功能描述：这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待） 
>
> `$#`（功能描述：这个变量代表命令行中所有参数的个数）



```sh
#!/bin/bash
  2 
  3 echo "命令为: $0"
  4 echo "第1个参数为: $1"
  5 echo "第2 个参数为: $2"
  6 echo "第3 个参数为: $3"
  7 echo "第4个参数为: $4"
  8 echo "第5个参数为: $5"
  9 
 10 echo "全部参数: $*"
 11 echo "全部参数单独: $@"
```



## 预定于变量

`shell`设计者事先已经定义好的变量，可以直接在`shell`脚本中使用



> `$$` （功能描述：当前进程的进程号（PID） 
>
> `$!` （功能描述：后台运行的最后一个进程的进程号（PID）
>
> `$?`（功能描述：最后一次执行的命令的返回状态。如果这个变量的值为 0，证明上一个命令正确执行；如果这个变量的值为非 0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。



```sh
#!/bin/bash

echo "当前进行的PID: $$"

echo "后台运行的最后一个PID: $!"


echo "最后一次: $?"
```



## 运算符



### 基本语法

> 1. `$((运算式))` or `$[运算式]` or `expr m + n` 
>
>    expr为`expression 表达式 `
>
> 2. 注意expr运算符间要有空格, 如果希望将expr的结果赋给某个变量，使用 `` 
>
> 3. `expr m - n` 
>
> 4. `expr \*, /, % `乘，除，取余
>
>    > `\*,/,%`等只是对于expr表达式，如果使用的是`$()`或者`$[]`便不需要



```sh
#!/bin/bash

RES=$((( 2+3) * 4 ))
echo "计算1: $RES"

RES1=$[(2+3) * 4]
echo "计算2: $RES1"

RES2=`expr 2 + 3`

echo "$RES2"
RES3=`expr $RES2 \* 4`

echo "expr: $RES3"
```

::: warning

如果你使用`expr`，那么一定要加上``，否怎会报错

```sh
#错误
RES=expr 2 + 3

#正确
RES=`expr 2 + 3`
```

:::



## 条件判断









### 常用判断条件

1. 字符串

    - `=` 字符串比较 

2. 数字

    - `-lt` 小于 
    
    - `-le` 小于等于 little equal 
    
    - `-eq` 等于 
    
    - `-gt` 大于 
    
    - `-ge` 大于等于 
    
    - `-ne` 不等于

3. 按照文件权限或者文件

     - `-r` 有读的权限 
     - `-w` 有写的权限 
     - `-x` 有执行的权限 
4. 按照文件类型进行判断 
     - `-f` 文件存在并且是一个常规的文件 
     - `-e` 文件存在 
     - `-d` 文件存在并是一个目录



### 案例

> 案例 1："ok"是否等于"ok" 
>
> 案例 2：23 是否大于等于 22 
>
> 案例 3：/root/shcode/aaa.txt 目录中的文件是否存在
>
> 案例 4：判断是否存在环境变量

```sh
#!/bin/bash

if [ "ok" = "ok" ]
then
        echo "ok 等于 ok"
fi

if [ 23 -ge 22 ]
then
        echo "23大于22"

fi

if [ -f /root/code/a.txt ]
then
        echo "a.txt文件存在"

fi

if [ $PATH ]
then
        echo "PATH存在环境变量: $PATH"
fi
```



::: warning

经过测试发现，不能如下取反

```sh
if [ !$PATH ]
then 
	echo ""
	
fi
```

:::





### 流程控制

- 单分支

  ```sh
  if [ condition ]
  then
  	#条件成立执行的代码
  fi
  ```

  `一定要使用fi`结束

- 多分支

  ```sh
  if [ condition ]
  then
  	#成立
  elif [ condition2 ]
  then
  	#条件2成立
  fi
  ```

  ![image-20211221192752076](https://ooszy.cco.vin/img/blog-note/image-20211221192752076.png?x-oss-process=style/pictureProcess1)





shell脚本语法太难了，后续需要再慢慢学o(╥﹏╥)oo(╥﹏╥)o





